<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenWakeWord Client (Advanced)</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f4f4f9; }
        h1 { color: #333; margin-bottom: 10px; }
        .card { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .status { font-weight: bold; color: #666; }
        .status.connected { color: green; }
        .status.disconnected { color: red; }
        
        button { padding: 12px 24px; font-size: 16px; cursor: pointer; border: none; border-radius: 4px; margin-right: 10px; font-weight: bold; transition: background 0.3s;}
        #btnStart { background-color: #28a745; color: white; }
        #btnStart:hover { background-color: #218838; }
        #btnStart:disabled { background-color: #ccc; cursor: not-allowed; }
        
        #btnStop { background-color: #dc3545; color: white; }
        #btnStop:hover { background-color: #c82333; }
        #btnStop:disabled { background-color: #ccc; cursor: not-allowed; }

        #logArea { background: #1e1e1e; color: #0f0; padding: 15px; height: 300px; overflow-y: scroll; border-radius: 4px; font-family: 'Consolas', monospace; font-size: 14px; }
        .highlight { color: #fff; background: #d32f2f; padding: 2px 6px; border-radius: 3px; font-weight: bold; }
        
        /* Style cho ph·∫ßn settings */
        .settings-group { display: flex; gap: 20px; margin-bottom: 15px; flex-wrap: wrap; }
        .checkbox-wrapper { display: flex; align-items: center; cursor: pointer; user-select: none; }
        .checkbox-wrapper input { margin-right: 8px; transform: scale(1.2); }
        .note { font-size: 0.9em; color: #666; font-style: italic; margin-top: 5px; }
    </style>
</head>
<body>

    <h1>üéôÔ∏è OpenWakeWord Client</h1>
    <p class="note">ƒê√£ t√≠ch h·ª£p x·ª≠ l√Ω √¢m thanh n√¢ng cao</p>

    <!-- Khu v·ª±c c·∫•u h√¨nh Audio -->
    <div class="card">
        <h3>‚öôÔ∏è C·∫•u h√¨nh Audio (Constraints)</h3>
        <div class="settings-group">
            <label class="checkbox-wrapper" title="Gi·∫£m ti·∫øng ·ªìn m√¥i tr∆∞·ªùng (qu·∫°t, ƒëi·ªÅu h√≤a...)">
                <input type="checkbox" id="chkNoise" checked> Kh·ª≠ ·ªìn (Noise Suppression)
            </label>
            <label class="checkbox-wrapper" title="NgƒÉn √¢m thanh t·ª´ loa v·ªçng l·∫°i v√†o mic">
                <input type="checkbox" id="chkEcho" checked> Kh·ª≠ v·ªçng (Echo Cancellation)
            </label>
            <label class="checkbox-wrapper" title="T·ª± ƒë·ªông tƒÉng/gi·∫£m √¢m l∆∞·ª£ng mic cho ƒë·ªÅu">
                <input type="checkbox" id="chkGain" checked> T·ª± ƒë·ªông Gain (AGC)
            </label>
        </div>
        <p class="note" style="margin-top:0">* L∆∞u √Ω: C·∫ßn d·ª´ng v√† b·∫Øt ƒë·∫ßu l·∫°i ƒë·ªÉ √°p d·ª•ng thay ƒë·ªïi.</p>
    </div>

    <div class="card">
        <p>Tr·∫°ng th√°i WebSocket: <span id="wsStatus" class="status disconnected">Ch∆∞a k·∫øt n·ªëi</span></p>
        <p>Model: <span id="modelList" style="font-weight: bold; color: #007bff">...</span></p>
        
        <div style="margin-top: 20px;">
            <button id="btnStart" onclick="startRecording()">üî¥ B·∫Øt ƒë·∫ßu</button>
            <button id="btnStop" onclick="stopRecording()" disabled>‚¨õ D·ª´ng</button>
        </div>
    </div>

    <div class="card">
        <h3>üìù Log ho·∫°t ƒë·ªông:</h3>
        <div id="logArea"></div>
    </div>

    <script>
        const WS_URL = 'ws://localhost:9000/ws';
        
        let socket;
        let audioContext;
        let mediaStream;
        let scriptProcessor;

        const wsStatus = document.getElementById('wsStatus');
        const btnStart = document.getElementById('btnStart');
        const btnStop = document.getElementById('btnStop');
        const logArea = document.getElementById('logArea');
        const modelListSpan = document.getElementById('modelList');

        // L·∫•y element settings
        const chkNoise = document.getElementById('chkNoise');
        const chkEcho = document.getElementById('chkEcho');
        const chkGain = document.getElementById('chkGain');

        function log(msg, isHighlight = false) {
            const div = document.createElement('div');
            const time = new Date().toLocaleTimeString();
            div.innerHTML = `<span style="color:#888">[${time}]</span> ${msg}`;
            if (isHighlight) div.innerHTML = `<span style="color:#888">[${time}]</span> <span class="highlight">${msg}</span>`;
            logArea.appendChild(div);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function connectWebSocket() {
            socket = new WebSocket(WS_URL);

            socket.onopen = () => {
                wsStatus.textContent = "ƒê√£ k·∫øt n·ªëi";
                wsStatus.className = "status connected";
                log("ƒê√£ k·∫øt n·ªëi t·ªõi Server Python.");
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                if (data.loaded_models) {
                    modelListSpan.textContent = data.loaded_models.join(", ");
                }
                if (data.activations && data.activations.length > 0) {
                    log(`PH√ÅT HI·ªÜN T·ª™ KH√ìA: ${data.activations.join(", ")}`, true);
                }
            };

            socket.onclose = () => {
                wsStatus.textContent = "ƒê√£ ng·∫Øt k·∫øt n·ªëi";
                wsStatus.className = "status disconnected";
                log("M·∫•t k·∫øt n·ªëi server.");
                stopRecording();
            };

            socket.onerror = (error) => {
                log("L·ªói WebSocket. Ki·ªÉm tra l·∫°i server.");
            };
        }

        connectWebSocket();

        async function startRecording() {
            if (!socket || socket.readyState !== WebSocket.OPEN) {
                alert("ƒêang k·∫øt n·ªëi l·∫°i server...");
                connectWebSocket();
                return;
            }

            try {
                // --- C·∫§U H√åNH AUDIO N√ÇNG CAO ---
                const constraints = {
                    audio: {
                        channelCount: 1, // Mono (Wake word kh√¥ng c·∫ßn Stereo)
                        echoCancellation: chkEcho.checked,
                        noiseSuppression: chkNoise.checked,
                        autoGainControl: chkGain.checked
                    }
                };
                
                log(`ƒêang xin quy·ªÅn Mic v·ªõi: NS=${chkNoise.checked}, EC=${chkEcho.checked}, AGC=${chkGain.checked}`);

                // G·ªçi getUserMedia v·ªõi c√°c tham s·ªë ƒë√£ c·∫•u h√¨nh
                mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Kh·ªüi t·∫°o AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // G·ª≠i Sample Rate cho server
                log(`Sample Rate: ${audioContext.sampleRate}Hz`);
                socket.send(audioContext.sampleRate.toString());

                const source = audioContext.createMediaStreamSource(mediaStream);
                scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);

                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                    if (socket.readyState !== WebSocket.OPEN) return;

                    const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                    // Chuy·ªÉn ƒë·ªïi v√† g·ª≠i
                    socket.send(convertFloat32ToInt16(inputData));
                };

                btnStart.disabled = true;
                btnStop.disabled = false;
                
                // Disable settings khi ƒëang ch·∫°y
                chkNoise.disabled = chkEcho.disabled = chkGain.disabled = true;

                log("ƒêang l·∫Øng nghe...");

            } catch (err) {
                console.error(err);
                log("L·ªói: " + err.message);
                alert("Kh√¥ng th·ªÉ truy c·∫≠p Microphone. H√£y ki·ªÉm tra quy·ªÅn truy c·∫≠p.");
            }
        }

        function stopRecording() {
            if (scriptProcessor) {
                scriptProcessor.disconnect();
                scriptProcessor = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            btnStart.disabled = false;
            btnStop.disabled = true;
            
            // Enable settings l·∫°i
            chkNoise.disabled = chkEcho.disabled = chkGain.disabled = false;
            
            log("ƒê√£ d·ª´ng.");
        }

        function convertFloat32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i < float32Array.length; i++) {
                let s = Math.max(-1, Math.min(1, float32Array[i]));
                int16Array[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return int16Array.buffer;
        }

    </script>
</body>
</html>